mixin snapshotDetail(snapshot)
	- var pricem2 = Math.round(snapshot.price / snapshot.area)
	.lastDate
		a(href=`../listing/${snapshot.snapshotDate}/${snapshot.id}.html`)
			=new Intl.DateTimeFormat("pl-PL", { day: 'numeric', month: 'long' }).format(fn.parseDate(snapshot.snapshotDate))
	.pricem2= fn.formatMoney(pricem2) + '/m²'

doctype html
html(lang="pl")
	head
		meta(charset='utf-8')
		title= 'Report'
		link(rel='stylesheet', type='text/css', href=`../report.css?${Math.random()}`)
	body
		div(class='auctions')

			each auction, auctionId in report
				- var firstSnapshot = auction.snapshots[0]
				- var lastSnapshot = auction.snapshots.at(-1)
				- var priceChange = Math.round((lastSnapshot.price - firstSnapshot.price) / firstSnapshot.price * 100)
				- var banned = bannedUrls.includes(lastSnapshot.url) ? 'banned' : ''
				- var fav = favUrls.includes(lastSnapshot.url) ? 'fav' : ''
				- var dead = deadUrls.includes(lastSnapshot.url) ? 'dead' : ''
				- var ended = auction.ended ? 'ended' : ''
				- var className = ['auction', banned, fav, dead, ended].join(' ')
				div(class=className, data-price-drop=priceChange < 0, data-price-rise=priceChange > 0)
					- var snapshots = auction.snapshots.toReversed()
					a(class='otodomAuctionLink', href=lastSnapshot.url, target='_blank', style="--background: url('" + lastSnapshot.imgUrls[0] + "')" )
					.header
						.title= lastSnapshot.title
						.priceChange
							| #{priceChange}%
					.summary
						.street= lastSnapshot.address.street 
						.floor= lastSnapshot.floor == 0 ? 'parter' : `${lastSnapshot.floor}. piętro`
					.details
						.area= Math.round(lastSnapshot.area) + 'm²'
						.price= fn.formatMoney(lastSnapshot.price)
					.history(style=`--snapshots-count: ${snapshots.length-1};`)
						- var scale = auction.normalized.scale;
						- var xMargin = 2;
						- var yMargin = scale.priceMargin / 2
						svg(class='priceChart', viewBox=`-${xMargin} 0 ${scale.date + xMargin * 2} ${scale.price + 20}`)
							- 
								var chronos = snapshots.toReversed()
								var chronosPoints = [{ x: 0, y: scale.price - chronos[0].normalized.price }]
									.concat(
										Array.from(chronos.entries())
											.map(([i, s]) => {
												const next = chronos[i+1];
												const offset = next && s.price != next?.price 
													? (next?.normalized.date - s.normalized.date - 2) 
													: 0;
												return { x: s.normalized.date + offset, y: scale.price - s.normalized.price };
											}))
								var svgPoints = chronosPoints
									.map(p => `${p.x},${p.y}`)
								var fillPoints = chronosPoints
									.concat([
										{ x: scale.date, y: scale.price },
										{ x: 0, y: scale.price }
									])
									.map(p => `${p.x},${p.y}`)
							defs
								linearGradient(id=`fillGradient${auctionId}`, gradientTransform='rotate(90)')
									stop(offset='0%', stop-color='var(--price-bg-color)')
									stop(offset='50%', stop-color='var(--price-bg-color)')
									stop(offset='100%', stop-color='white')
							g
								polygon(points=fillPoints.join(' '), fill=`url(#fillGradient${auctionId})`)
							- var index = 0
							while index < chronosPoints.length - 1
								- 
									var point = chronosPoints[index]
									var priceChangeIndex = chronosPoints.slice(index)
										.findIndex(p => p.y != point.y)
									priceChangeIndex = priceChangeIndex != -1 ? index + priceChangeIndex : chronosPoints.length;
									var chartPoints = [chronosPoints[index]]
										.concat(chronosPoints[priceChangeIndex - 1], chronosPoints[priceChangeIndex])
										.filter(p => p != undefined)	
									var points = chartPoints
										.concat({ x: chartPoints.at(-1).x, y: scale.price }, { x: point.x, y: scale.price })
								g.price
									polygon(points=points.map(p => `${p.x},${p.y}`).join(' '), tabindex=-1)
									polyline(points=points.filter(p => p.y != scale.price).map(p => `${p.x},${p.y}`).join(' '))
									- 
										var price = fn.formatMoney(chronos[index].price)
										var priceWidth = price.length * 3.67 + 3
										var trans = fn.translatePriceInfo(
											{ x: 0, y: 0, width: scale.date, height: scale.price },
											points,
											point.x, point.y, priceWidth, 10)
										var dateRange = [
											Math.min(...points.map(p => p.x)),
											Math.max(...points.map(p => p.x))]
									g.priceInfo(transform=`translate(${trans.x}, ${trans.y})`)
										rect(x=point.x, y=point.y, width=priceWidth, height=10, rx=2)
										text(x=point.x + priceWidth / 2 - 0.4, y=point.y + 6, text-anchor='middle' dominant-baseline='middle')
											| #{price}
								- index = priceChangeIndex
					.history(style=`--snapshots-count: ${snapshots.length-1};`)
						details
							summary.snapshot
								+ snapshotDetail(snapshots[0])
						.snapshots
							each snapshot, index in snapshots.splice(1)
								.snapshot
									+ snapshotDetail(snapshot)
								

